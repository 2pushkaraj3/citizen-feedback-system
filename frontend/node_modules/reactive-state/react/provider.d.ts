import { Store } from "../src/index";
import * as React from "react";
export interface StoreProviderProps {
    store: Store<{}>;
}
export declare class StoreProvider extends React.Component<StoreProviderProps, {}> {
    render(): JSX.Element;
}
export declare const StoreConsumer: React.Consumer<Store<any> | undefined>;
export interface StoreSliceProps<TAppState, TKey extends keyof TAppState> {
    slice: (store: Store<TAppState>) => TKey;
    initialState?: TAppState[TKey];
    cleanupState?: TAppState[TKey] | "delete" | "undefined";
}
export declare class StoreSlice<TAppState, TKey extends keyof TAppState> extends React.Component<StoreSliceProps<TAppState, TKey>, {}> {
    slice?: Store<TAppState[TKey]>;
    componentWillUnmount(): void;
    render(): JSX.Element;
}
export interface StoreProjectionProps<TState, TProjected> {
    forwardProjection: (state: TState) => TProjected;
    backwardProjection: (projectedState: TProjected, parentState: TState) => TState;
    cleanup?: (state: TProjected, parentState: TState) => TState;
    initial?: (state: TState) => TProjected;
}
export declare const StoreProjection: {
    new <TState, TProjected>(props: StoreProjectionProps<TState, TProjected> | Readonly<StoreProjectionProps<TState, TProjected>>): {
        slice?: Store<TProjected> | undefined;
        componentWillUnmount(): void;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<StoreProjectionProps<TState, TProjected>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<StoreProjectionProps<TState, TProjected>> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<StoreProjectionProps<TState, TProjected>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<StoreProjectionProps<TState, TProjected>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new <TState, TProjected>(props: StoreProjectionProps<TState, TProjected>, context: any): {
        slice?: Store<TProjected> | undefined;
        componentWillUnmount(): void;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<StoreProjectionProps<TState, TProjected>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<StoreProjectionProps<TState, TProjected>> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<StoreProjectionProps<TState, TProjected>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<StoreProjectionProps<TState, TProjected>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<StoreProjectionProps<TState, TProjected>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};
export declare class WithStore extends React.Component<{}, {}> {
    render(): JSX.Element;
}
/**
 * A react hook to obtain the current store, depending on the context.
 */
export declare function useStore<T = {}>(): Store<T>;
/**
 * A react hook to mirror the pattern of connect through a hooks-based interface.
 */
export declare function useStoreState(): object;
export declare function useStoreState<TState extends object>(): TState;
export declare function useStoreState<TState extends object, TSlice extends object>(projection: (state: TState) => TSlice): TSlice;
/**
 * A react hook to create a fluent interface for producing a hook that makes state slices.
 * Useful mainly for infering the type of the slice; when the type of slice is known, useStoreState is cleaner.
 */
export declare function useStoreSlices<TState extends object>(): <TSlice extends object>(projection: (state: TState) => TSlice) => TSlice;
