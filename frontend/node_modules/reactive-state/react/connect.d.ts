import * as React from "react";
import { Observable } from "rxjs";
import { Store } from "../src/store";
import { ActionMap } from "./actions";
export declare type ExtractProps<TComponentOrTProps> = TComponentOrTProps extends React.ComponentType<infer TProps> ? TProps : TComponentOrTProps;
export interface ConnectResult<TAppState, TOriginalProps, TConnectedProps> {
    props?: Observable<TConnectedProps>;
    actionMap?: ActionMap<TOriginalProps>;
}
export declare type ConnectCallback<TAppState, TOriginalProps, TConnectedProps, TInputProps> = (store: Store<TAppState>, inputProps: Observable<TInputProps>) => ConnectResult<TAppState, TOriginalProps, TConnectedProps>;
export interface ConnectState<TOriginalProps, TConnectedProps> {
    connectedProps?: TConnectedProps;
    ready: boolean;
}
/**
 * Connects a Component's props to a set of props of the application state coming from a Store object.
 */
export declare function connect<TAppState, TOriginalProps extends {}, TConnectedProps extends {}, TInputProps extends {} = {}>(ComponentToConnect: React.ComponentType<TOriginalProps>, connectCallback: ConnectCallback<TAppState, TOriginalProps, TConnectedProps, TInputProps>): {
    new (props: any): {
        render(): JSX.Element;
        context: any;
        setState<K extends "connectedProps" | "ready">(state: ConnectState<TOriginalProps, TConnectedProps> | ((prevState: Readonly<ConnectState<TOriginalProps, TConnectedProps>>, props: Readonly<TInputProps & Pick<TOriginalProps, Exclude<keyof TOriginalProps, keyof TConnectedProps>>>) => ConnectState<TOriginalProps, TConnectedProps> | Pick<ConnectState<TOriginalProps, TConnectedProps>, K> | null) | Pick<ConnectState<TOriginalProps, TConnectedProps>, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<TInputProps & Pick<TOriginalProps, Exclude<keyof TOriginalProps, keyof TConnectedProps>>> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<ConnectState<TOriginalProps, TConnectedProps>>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<TInputProps & Pick<TOriginalProps, Exclude<keyof TOriginalProps, keyof TConnectedProps>>>, nextState: Readonly<ConnectState<TOriginalProps, TConnectedProps>>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<TInputProps & Pick<TOriginalProps, Exclude<keyof TOriginalProps, keyof TConnectedProps>>>, prevState: Readonly<ConnectState<TOriginalProps, TConnectedProps>>): any;
        componentDidUpdate?(prevProps: Readonly<TInputProps & Pick<TOriginalProps, Exclude<keyof TOriginalProps, keyof TConnectedProps>>>, prevState: Readonly<ConnectState<TOriginalProps, TConnectedProps>>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<TInputProps & Pick<TOriginalProps, Exclude<keyof TOriginalProps, keyof TConnectedProps>>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<TInputProps & Pick<TOriginalProps, Exclude<keyof TOriginalProps, keyof TConnectedProps>>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<TInputProps & Pick<TOriginalProps, Exclude<keyof TOriginalProps, keyof TConnectedProps>>>, nextState: Readonly<ConnectState<TOriginalProps, TConnectedProps>>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<TInputProps & Pick<TOriginalProps, Exclude<keyof TOriginalProps, keyof TConnectedProps>>>, nextState: Readonly<ConnectState<TOriginalProps, TConnectedProps>>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};
