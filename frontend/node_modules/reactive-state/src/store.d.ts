import { Observable, Subscription } from "rxjs";
import { CleanupState, Reducer, StateChangeNotification } from "./types";
export declare class Store<S> {
    /**
     * Observable that emits when the store was destroyed using the .destroy() function.
     */
    readonly destroyed: Observable<void>;
    private readonly state;
    get currentState(): S;
    /**
     * All reducers always produce a state mutation of the original root store type R;
     * However, we only now type R for the root store; all other stores may have different type
     * so we use any here as the root type.
     */
    private readonly stateMutators;
    /**
     * A list of transformation functions that will transform the state to different projections
     * and backwards. Use for scoped reducers.
     */
    private readonly forwardProjections;
    private readonly backwardProjections;
    /**
     * Is completed when the slice is unsubscribed and no longer needed.
     */
    private readonly _destroyed;
    /**
     * Used for manual dispatches without observables
     */
    private readonly actionDispatch;
    private readonly stateChangeNotificationSubject;
    /**
     * Only used for debugging purposes (so we can bridge Redux Devtools to the store)
     * Note: Do not use in day-to-day code, use .select() instead.
     */
    readonly stateChangedNotification: Observable<StateChangeNotification>;
    private constructor();
    /**
     * Create a new Store based on an initial state
     */
    static create<S>(initialState?: S): Store<S>;
    /**
     * Creates a new linked store, that Selects a slice on the main store.
     * @deprecated
     */
    createSlice<K extends keyof S>(key: K, initialState?: S[K], cleanupState?: CleanupState<S[K]>): Store<S[K]>;
    /**
     * Create a clone of the store which holds the same state. This is an alias to createProjection with
     * the identity functions as forward/backwards projection. Usefull to unsubscribe from select()/watch()
     * subscriptions as the destroy() event is specific to the new cloned instance (=will not destroy the original)
     * Also usefull to scope string-based action dispatches to .dispatch() as action/reducers pairs added to the
     * clone can not be dispatched by the original and vice versa.
     */
    clone(): Store<S>;
    /**
     * Creates a new slice of the store. The slice holds a transformed state that is created by applying the
     * forwardProjection function. To transform the slice state back to the parent state, a backward projection
     * function must be given.
     * @param forwardProjection - Projection function that transforms a State S to a new projected state TProjectedState
     * @param backwardProjection - Back-Projection to obtain state S from already projected state TProjectedState
     * @param initial - Function to be called initially with state S that must return an initial state to use for TProjected
     * @param cleanup  - Function to be called when the store is destroyed to return a cleanup state based on parent state S
     */
    createProjection<TProjectedState>(forwardProjection: (state: S) => TProjectedState, backwardProjection: (state: TProjectedState, parentState: S) => S, initial?: (state: S) => TProjectedState, cleanup?: (state: TProjectedState, parentState: S) => S): Store<TProjectedState>;
    /**
     * Adds an Action/Reducer pair. This will make the reducer become active whenever the action observable emits a
     * value.
     * @param action An observable whose payload will be passed to the reducer on each emit, or a string identifier
     *        as an action name. In the later case, .dispatch() can be used to manually dispatch actions based
     *        on their string name.
     * @param reducer A reducer function. @see Reducer
     * @param actionName An optional name (only used during development/debugging) to assign to the action when an
     *        Observable is passed as first argument. Must not be specified if the action argument is a string.
     */
    addReducer<P>(action: Observable<P> | string, reducer: Reducer<S, P>, actionName?: string): Subscription;
    /**
     * Selects a part of the state using a selector function. If no selector function is given, the identity function
     * is used (which returns the state of type S).
     * Note: The returned observable does only update when the result of the selector function changed
     *       compared to a previous emit. A shallow copy test is performed to detect changes.
     *       This requires that your reducers update all nested properties in
     *       an immutable way, which is required practice with Redux and also with reactive-state.
     *       To make the observable emit any time the state changes, use .select() instead
     *       For correct nested reducer updates, see:
     *         http://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html#updating-nested-objects
     *
     * @param selectorFn    A selector function which returns a mapped/transformed object based on the state
     * @returns             An observable that emits the result of the selector function after a
     *                      change of the return value of the selector function
     */
    watch<T = S>(selectorFn?: (state: S) => T): Observable<T>;
    /**
     * Same as .watch() except that EVERY state change is emitted. Use with care, you might want to pipe the output
     * to your own implementation of .distinctUntilChanged() or use only for debugging purposes.
     */
    select<T = S>(selectorFn?: (state: S) => T): Observable<T>;
    /**
     * Destroys the Store/Slice. All Observables obtained via .select() will complete when called.
     */
    destroy(): void;
    /**
     * Manually dispatch an action by its actionName and actionPayload.
     *
     * This function exists for compatibility reasons, development and devtools. It is not adviced to use
     * this function extensively.
     *
     * Note: While the observable-based actions
     * dispatches only reducers registered for that slice, the string based action dispatch here will forward the
     * action to ALL stores, (sub-)slice and parent alike so make sure you separate your actions based on the strings.
     */
    dispatch<P>(actionName: string, actionPayload: P): void;
}
